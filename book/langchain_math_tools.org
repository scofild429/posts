
*  Langchain tool examples
So I let the agent to chose one out of four for math operation

#+begin_src python
from langchain_core.runnables import RunnableConfig
import warnings
from langchain.agents import create_agent, AgentState
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langgraph.checkpoint.memory import MemorySaver
from langgraph.prebuilt.tool_node import ToolRuntime
from langgraph.types import Command
from langchain_core.messages import ToolMessage
import os
warnings.filterwarnings("ignore")


# Step 3: Create agent with custom state
model = ChatOpenAI(
    model="gpt-4o-mini",  # ty:ignore[unknown-argument]
    api_key=str(os.getenv("OPENAI_API_KEY"))   # ty:ignore[unknown-argument]
)
checkpointer = MemorySaver()


# Step 1: Define custom state by extending AgentState
class OperationState(AgentState):
    first: int = 0
    second: int = 0

    
@tool
def add_tool(runtime: ToolRuntime) -> Command:
    """Add the first and second two number together"""
    first: int = runtime.state.get("first", 0)
    second: int = runtime.state.get("second", 0)
    result = first + second
    print(f"SUM of {first} and {second} is {result}\n")
    return Command(
        update={
            "first": result,
            "messages": [ToolMessage(
                content=f"The sum of {first} and {second} is {result}. 'first' has been updated to {result}.",
                tool_call_id=runtime.tool_call_id
            )]
        }
    )

@tool
def subtract_tool(runtime: ToolRuntime) -> Command:
    """Subtract the second number from the first number"""
    first: int = runtime.state.get("first", 0)
    second: int = runtime.state.get("second", 0)
    result = first - second
    print(f"DIFFERENCE of {first} and {second} is {result}\n")
    return Command(
        update={
            "first": result,
            "messages": [ToolMessage(
                content=f"The difference of {first} - {second} is {result}. 'first' has been updated to {result}.",
                tool_call_id=runtime.tool_call_id
            )]
        }
    )

@tool
def multiply_tool(runtime: ToolRuntime) -> Command:
    """Multiply the first and second numbers"""
    first: int = runtime.state.get("first", 0)
    second: int = runtime.state.get("second", 0)
    product = first * second
    print(f"PRODUCT of {first} and {second} is {product}\n")
    return Command(
        update={
            "first": product,
            "messages": [ToolMessage(
                content=f"The product of {first} * {second} is {product}. 'first' has been updated to {product}.",
                tool_call_id=runtime.tool_call_id
            )]
        }
    )

@tool
def divide_tool(runtime: ToolRuntime) -> Command:
    """Divide the first number by the second number"""
    first: int = runtime.state.get("first", 0)
    second: int = runtime.state.get("second", 1)
    if second == 0:
        return Command(
            update={
                "messages": [ToolMessage(
                    content="Error: Division by zero is undefined.",
                    tool_call_id=runtime.tool_call_id
                )]
            }
        )
    quotient = first / second
    print(f"QUOTIENT of {first} and {second} is {quotient}\n")
    return Command(
        update={
            "first": quotient,
            "messages": [ToolMessage(
                content=f"The result of {first} / {second} is {quotient}. 'first' has been updated to {quotient}.",
                tool_call_id=runtime.tool_call_id
            )]
        }
    )

@tool
def get_values(runtime: ToolRuntime) -> str:
    """Print the current value of first and second"""
    first: int = runtime.state.get("first", 0)
    second: int = runtime.state.get("second", 1)
    return f"the current value for first is {first}, and for second is {second}\n"


print("=" * 60)
print("Try commands like do addition, substraction, multiplication or division")
print("Type 'quit' to exit.")
print("=" * 60)


SYSTEM_PROMPT = """You are a math assistant. You have access to two state variables:
- 'first': a number that stores the first operand and results
- 'second': a number that stores the second operand

When the user asks to perform a math operation (add, subtract, multiply, divide),
call the appropriate tool immediately. The tools will use the current state values.
Do NOT ask the user for numbers - the tools read from the state automatically.

After each operation, the 'first' value is updated with the result.
Use get_values to show the current state values."""

# Create final agent with all tools
full_agent = create_agent(
    model=model,
    tools=[add_tool, subtract_tool, multiply_tool, divide_tool, get_values],
    state_schema=OperationState,
    checkpointer=checkpointer
)

# Test the full agent with state updates
config = {
    "configurable": {"thread_id": "demo-1"}
}

# Initialize state with starting values
initial_state = {
    "messages": [
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": "I'm ready to do math operations."}
    ],
    "first": 1000,
    "second": 10
}

# Initialize the agent with starting state
full_agent.invoke(initial_state, config=RunnableConfig(config))

def chat(message: str):
    """Helper function to chat with the agent."""
    result = full_agent.invoke(
        {"messages": [{"role": "user", "content": message}]},
        config=RunnableConfig(config)
    )
    response = result['messages'][-1].content
    print(f"\nAgent: {response}\n")
    print(f"Current state - first: {result.get('first', 'N/A')}, second: {result.get('second', 'N/A')}\n")
    return result

# Interactive loop
while True:
    user_input = input("\nYou: ")
    if user_input.lower() in ['quit', 'exit', 'q']:
        print("Goodbye!")
        break
    if user_input.strip():
        chat(user_input)


#+end_src


